# ZipStreams
A Julia package to burn through ZIP archives as fast as possible by ignoring
standards just a little bit.

## Overview
> "There are three ways to do things: the right way, the wrong way, and the Max Power way."
>
> -Homer from The Simpsons, season 10, episode 13: "Homer to the Max"

ZIP archives are optimized for _appending_ and _deleting_ operations. This is
because the canonical source of information for what is stored in a ZIP archive
is the "Central Directory", data written at the very end of the archive. Users
who want to append a file to the archive can overwrite the Central Directory with
new file data, then append a new, updated Central Directory afterward, and nothing
else in the file has to be touched. Likewise, users who want to delete files in
the archive only have to change the entries in the Central Directory: readers
that conform to the _de facto_ standard described in the [PKWARE APPNOTE file](https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT)
will ignore the files that are no longer cataloged.

This design choice means that standards-conformant readers like [`ZipFile.jl`](https://github.com/fhs/ZipFile.jl)
cannot know what files are stored in a ZIP archive until they read the very end of
the file. While this is not typically a problem on modern SSD-based storage where
random file access is fast, it is a major limitation on stream-based file storage
systems like networks, where readers typically have no choice but to read an
entire file from beginning to end in order, and to seek from the end back to
where a given file is stored in the archive, one has to buffer _the entire file_
in memory or on disk. Again, this is not a problem for archives with sizes on the
order of megabytes, but standard ZIP archives can be as large as 4GB, which can
easily overwhelm systems with limited memory or storage like embedded systems or
cloud-based micro-instances, and ZIP64 archives can be 16 EB (2^64 bytes), which
can easily overwhelm even the largest of modern supercomputers.

However, the ZIP archive specification also states that each file in the archive
have a "Local File Header" preceeding the (possibly compressed) file data. The
Local File Header contains enough information to allow a reader to extract the
file and perform simple error checking immediately, so long as three conditions
are met:
1. The information in the Local File Header is correctly specified. The Central
Directory is the canonical source of information, so the Local File Header could
be lying.
2. The Central Directory is not encrypted. File sizes and checksum values are
masked from the Local File Header if the Central Directory is encrypted, so it is
impossible to know where the file ends.
3. The file was not stored with a "Data Descriptor" (general purpose flag 3). This
is typically used only when the file is _written_ to the archive in a streaming
fashion.

That being said, most users will never see ZIP files that cannot be extracted
exclusively using Local File Header information.

## Benchmarks

This package is designed to be fast. See [this page]() for benchmark results
against other standard ZIP archive readers.

## DO NOT BLINDLY TRUST ZIP ARCHIVES

By ignoring standards, this module makes no guarantees that what you get out of
the ZIP archive matches what you or anyone else put into it. The code is tested
against ZIP archives generated by various writers, but there are corner cases,
ambiguities in the standard, and even pathological ZIP files in the wild that may
silently break this package.

> _Bart:_ "Isn't that the wrong way?"
>
> _Homer:_ "Yeah, but faster!"
>
> -The Simpsons, season 10, episode 13: "Homer to the Max"

You have been warned!

## Installation and use

Install via the Julia package manager, `Pkg.add("ZipStreams")`.

You can wrap any Julia `IO` object with the `zipstream` function. The returned
struct can be iterated to read archived files in archive order. Information about
each file is stored in the `.info` property of the struct returned from the
iterator. The struct returned from the iterator is readable like any standard
Julia `IO` object.

Here are some examples:

```julia
using ZipStreams

# open an archive
open("archive.zip") do io
    zs = zipstream(io)

    # iterate through files
    for f in zs
        
        # get information about each file from the .info property
        println(f.info.name)

        # read from the file just like any other IO object
        println(readline(f))
        
        println(read(f, String))
    end
end

# open an enormous file from a network stream
using BufferedStreams
using HTTP
HTTP.open(:GET, "https://download.cms.gov/nppes/NPPES_Data_Dissemination_August_2022.zip") do http
    zipstream(BufferedInputStream(http)) do zs
        for f in zs
            println(f.info.name)
            break
        end
    end
end

# convenience method for opening an archive as a zipstream
zs = zipstream("archive.zip")
close(zs)

# convenience method for automatically closing the archive when done
zipstream("archive.zip") do zs
    ...
end

# store additional information while iterating through the archive to allow validation
zipstream("archive.zip"; store_file_info=true, calculate_crc32s=true) do zs

    # validate individual files
    for f in zs
        validate(f) # throws if there is a problem
    end

    # validate the entire archive at once (including the individual files)
    validate(zs) # throws if there is a problem
end
```
